package main

/*
 * 类型推断(Type Inference):
 * 类型推断是编程语言在编译时自动解释表达式中数据类型的能力, 通常在函数式编程
 * 语言(如 Haskell)中存在; 类型推断的优势主要在与可以省略类型, 从而使得编程更
 * 加容易.
 *
 * 明确指出变量的类型在编程语言中很常见, 编译器支持类型推断的程度因语言而异.
 *
 * 类型推断的优势:
 * - 使代码更易阅读
 * - 如果类型比较复杂的情况下, 将减少代码冗余
 * 类型推断还具有动态语言的灵活特性, 例如: Haskell 语言的如下代码, 不管变量 x
 * 是什么类型, 都加 1 并返回结果:
 * succ x = x + 1
 *
 * 但显式的指出类型仍可以让编译器更好的了解代码实际应执行的操作, 而不会犯错.
 *
 *
 *
 * go 类型推断特性:
 * 不同的语言的类型推断能力不同, go 语言的目标是减少其他静态类型语言中存在的
 * 混乱情况; 因此在设计 go 语言时, 对变量使用简单的类型推断, 同时仍保留静态
 * 类型的好处.
 */

// 使用 := 表示法触发 go 的类型推断
// a := 333
// fmt.Println("type:%T", a) // type:int
// go 的类型系统禁止了不同类型之间的转换, 因此下例的 a 已经被推断为 int 类型,
// 不能赋值给 int64 类型
// a := 333
// var b int64
// b = a

// go 的类型推断在处理包含变量标识符的推断方面是半智能的, 本质上编译器禁止对
// 变量标识符引用的值进行强制类型转换(即对变量进行强制类型转换)
// a : = 1 + 1.1 // a 的类型为 float64

// 下面的代码仍然正确, a 被推断为浮点数, 1 会被转换为浮点数与 a 的值相加
// a := 1.1
// b := 1 + a

// 编译器报错: constant 1.1 truncated to interger
// a 的值已经被推断为整数, 而 1.1 为浮点数, 不能将 a 强制转换为浮点数, 相加失败
// a := 1
// b := a + 1.1

/* 类型推断原理 ./principle.go */
