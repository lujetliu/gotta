package main

/*
	垃圾收集器
	编程语言的内存管理系统除负责堆内存的分配外, 还负责回收不再使用的对象和
	内存空间, 这部分工作由垃圾收集器完成; 在几乎所有现代编程语言中, 垃圾
	收集器都是一个复杂的系统, 需要花费很多精力学习;


	c, c++ 和 rust 等编程语言使用手动方式管理内存, 程序员需要主动申请内存
	或者释放内存; 而 python, ruby, java 和 go 等语言使用自动内存管理系统,
	一般是垃圾收集机制, 不过 Object-C 选择了自动引用计数, 引用计数也是属
	于自动内存管理机制;

	在垃圾收集的时候需要进行STW(Stop the World)暂停程序(TODO)
	随着用户程序申请越来越多的内存, 系统中的垃圾会逐渐增多; 当程序的内存占用
	达到一定阈值时, 整个应用程序就会暂停, 垃圾收集器会扫描分配的所有对象并
	回收不再使用的内存空间, 当这个过程结束后, 用户程序才可以继续执行;

	用户程序会通过内存分配器在堆中申请内存, 而垃圾收集器负责回收堆中的内存
	空间, 内存分配器和垃圾收集器共同管理程序中的堆内存空间;
*/

/*
	标记清除(mark-sweep)
	标记清除算法是最常见的垃圾回收算法, 标记清除算法是跟踪式垃圾收集器, 其
	执行过程可以分为标记(mark)和清除(sweep)两个阶段:
	- 标记阶段: 从根对象出发查找并标记堆中所有存活的对象;
	- 清除阶段: 遍历堆中的全部对象, 回收未被标记的垃圾对象并将回收的内存
		加入空闲链表;(TODO: 源码)
	标记阶段结束后会进入清除阶段, 在该阶段收集器会依次遍历堆中的所有对象,
	释放其中没有被标记的对象, 并将新的空闲内存空间以链表的结构串联起来,
	方便内存分配器使用

	垃圾收集器从垃圾收集的根对象出发, 递归遍历这些对象指向的子对象并将所有
	可达的对象标记成存活; 标记阶段结束后, 垃圾收集器会依次遍历堆中的对象
	并清除其中的垃圾; 整个过程需要标记对象的存活状态, 用户程序在垃圾收集过
	程中也不能执行, 需要使用更复杂的机制来解决 STW 问题;

	三色抽象(TODO: 三色标记)
	为了解决原始标记清除算法带来的长时间 STW, 多数现代追踪式垃圾收集器会实现
	三色标记(ti-color marking)算法的变种以缩短 STW 的时间; 三色标记算法将程序
	中的对象分成白色, 黑色或灰色3类;
	- 白色对象: 潜在的垃圾, 其内存可能会被垃圾收集器回收;
	- 黑色对象: 活跃的对象, 包括不存在任何引用外部指针的对象以及从根对象可达
		的对象;
	- 灰色对象: 活跃的对象, 因为存在指向白色对象的外部指针, 所以垃圾收集器
		会扫描这些对象的子对象;

	在垃圾收集器开始工作时, 程序中不存在任何黑色对象, 垃圾收集器的根对象会被
	标记为灰色, 垃圾收集器只会从灰色对象集合中取出对象开始扫描, 当灰色集合中
	不存在任何对象时, 标记阶段就会结束; 其工作原理如下:
	- 从灰色对象的结合中选择一个灰色对象并将其标记成黑色;
	- 将黑色对象指向的所有对象都标记成灰色, 保证该对象和被该对象引用的对象
		都不会被回收;
	- 重复上述步骤直到对象图中不存在灰色对象;

	当三色标记清除的标记阶段结束后, 应用程序的堆中就不存在任何灰色对象了, 只能
	看到黑色和存活对象以及白色的垃圾对象, 垃圾收集器可以回收这些白色的垃圾;

	因为用户程序可能在标记执行过程中修改对象的指针, 所以三色标记清除算法本身
	是不可以并发或增量执行的, 仍然需要 STW; 如果在三色标记过程中, 用户程序
	建立了黑色对象到白色对象的引用, 但是因为程序中已经不存在灰色对象了, 所以
	白色对象会被垃圾收集器错误的回收; 本来不应该被回收的对象却被回收了, 这在
	内存管理中属于非常严重的错误, 将这种错误称为悬挂指针(dangling pointer), d
	即指针并没有指向特定类型的合法对象, 影响了内存的安全性, 要并发或者增量的
	标记对象需要使用屏障技术;(TODO: 并发和增量标记)
*/

/*
	屏障技术(TODO: 内存一致性问题)
	内存屏障(memory barrier) 技术是一种屏障指令, 它可以让 CPU 或者编译器在执行
	内存相关操作时遵守特定约束, 目前多数现代处理器会乱序执行指令以最大化性能,
	但是该技术能够保证内存操作的顺序性, 在内存屏障前执行的操作一定会先于内存
	屏障后执行的操作;

	如果要在并发过增量的标记算法中保证正确性, 需要达成以下两种
	三色不变性(tri-color invariant) 中的一种:
	- 强三色不变性: 黑色对象不会指向白色对象, 只会指向灰色对象或黑色对象;
	- 弱三色不变性: 黑色对象指向的白色对象必须包含一条从灰色对象经由多个
		白色对象的可达路径;

	垃圾收集中的屏障技术更像是一个钩子方法, 它是在用户程序读取对象, 创建新对象
	以及更新对象指针时执行的一段代码, 根据操作类型的不同, 可以分为读屏障(read
	barrier) 和写屏障(write barrier)两种; 因为读屏障需要在读操作中加入代码片段,
	对用户程序的性能影响很大, 所以编程语言往往会采用写屏障技术保证三色不变性;

	go语言中使用了两种写屏障技术, 分别是 Dijkstra 提出的插入写屏障和 Yuasa 提出
	的删除写屏障;

	Dijkstra 的插入写屏障技术: (A ----> B ----> C)
	假设在应用程序中使用 Dijkstra 提出的插入写屏障, 在一个垃圾收集器和用户程序
	交替运行的场景下会出现以下的标记过程:
	- 垃圾收集器将根对象指向的A对象标记程黑色并将A对象指向的B对象标记成灰色;
	- 用户程序修改A对象的指针, 将原本指向B对象的指针指向C对象, 这时触发写屏障
		将C对象标记成灰色;
	- 垃圾收集器依次遍历程序中的其他灰色对象, 将它们分别标记成黑色;

	Dijkstra 的插入写屏障是相对保守的屏障技术, 它会将有存活可能的对象都标记为
	灰色以满足强三色不变性;

	Dijkstra 的插入写屏障虽然实现简单并且能保证三色不变性, 但是其有明显的缺点;
	因为栈上的对象在垃圾收集过程中也会被认作根对象, 所以为了保证内存安全,
	必须为栈上的对象增加写屏障或在标记阶段重新扫描栈上的对象;
	但是为栈上的对象增加写屏障会大幅度增加写入指针的额外开销, 同时在标记阶段
	重新扫描栈上的对象的时候需要暂停程序, 需要在这两种方案之间做出权衡;


	Yuasa 的删除写屏障技术:(A ----> B ----> C ----> D)
	删除写屏障一旦开始工作, 它会保证开启写屏障时堆中所有对象可达, 所以也被
	称为快照垃圾收集(snapshot GC);
	假设在应用程序中使用 Yuasa 提出的删除写屏障, 在一个垃圾收集和用户程序
	交替运行的场景下会出现以下的标记过程:
	- 垃圾收集器将根对象指向的A对象标记成黑色并将A对象指向的B对象标记成灰色;
	- 用户程序将A对象原本指向B对象的指针指向C, 触发删除写屏障, 但是因为B对象
		已是灰色的, 所以不做改变;
	- 用户程序将B对象指向原本指向C的指针删除, 触发删除写屏障, 白色的C对象被
		涂成灰色;
	- 垃圾收集器依次遍历程序中的其他灰色对象, 将它们分别标记为黑色;

	上述第三步触发了删除写屏障的着色, 因为用户删除了B对象指向C对象的指针,
	所以C和D两个对象会分别违反强三色不变性和弱三色不变性:
	- 违反强三色不变性: 黑色的A对象直接指向白色的C对象
	- 违反弱三色不变性: 垃圾收集器无法从某个灰色对象出发, 经过几个连续的白色
		对象访问白色对象的C和D两个对象
	通过对C对象的着色, Yuasa 删除写屏障保证了C对象和下游的D对象能够在这次
	垃圾回收的循坏中存活, 避免发生悬挂指针以保证用户程序的正确性; 从而保证了
	满足强三色不变性或者弱三色不变性;

*/

/*
	增量和并发:
		传统的垃圾收集算法会在垃圾收集的执行器件暂停应用程序, 一旦触发垃圾收集,
		垃圾收集器会抢占CPU的使用权, 占据大量计算资源以完成标记和清除工作, 然而
		很多追求实时的应用程序无法接受长时间的 STW;

		为了缩短应用程序暂停的最长时间和垃圾收集的总暂停时间, 会使用以下的策略
		优化现代的垃圾收集器:
		- 增量垃圾收集: 增量的标记和清除垃圾, 降低应用程序暂停的最长时间;
		- 并发垃圾收集: 利用多核的计算资源, 在用户程序执行时并发标记和清除垃圾;

		因为增量和并发两种方式都可以与用户程序交替运行, 所以需要使用屏障技术
		保证垃圾回收的正确性, 同时, 应用程序也不能等到内存溢出时触发垃圾收集,
		因为当内存不足时, 程序已经无法分配内存, 这与直接暂停程序没有区别, 增量
		和并发的垃圾收集需要提前触发并在内存不足前完成整个循环, 避免程序长时间
		暂停;

	增量(incremental)收集器(先做了解):
		增量垃圾收集是缩短程序最长暂停时间的一种方案, 可以将原本较长的暂停时间
		切分成多个更小的GC时间片, 虽然从垃圾收集开始到结束的时间更长了, 但是
		应用程序暂停的最长时间缩短了;

	并发(concurrent)垃圾收集:
		并发垃圾收集不仅能缩短程序的最长暂停时间, 还能缩短整个垃圾收集阶段的时间,
		通过开启读写屏障, 利用多核优势与用户程序并行执行, 并发垃圾收集器确实能
		减少垃圾收集对应用程序的影响;

*/
