package main

/*
	垃圾回收
	TODO: <垃圾回收算法手册>
	在计算机科学中,垃圾回收(Garbage Collection, GC) 是自动内存管理的一种形式,
	通常由垃圾收集器收集并适时回收或重用不再被对象占用的内存;
	垃圾回收作为内存管理的一部分, 包含3个重要的功能:
	- 分配和管理新对象
	- 识别正在使用的对象
	- 清除不再使用的对象

	垃圾回收会让开发变得更加简单, 屏蔽了复杂且容易出错的操作


	垃圾回收的好处:
	- 减少错误和复杂性
		没有垃圾回收就必须手动分配内存, 释放内存; 不管是内存泄露还是野指针都
		会增加开发程序的难度, 虽然垃圾回收不保证完全不产生内存泄露, 但其提供了
		重要的保障, 即不再被引用的对象最终被收集, 这种设定同样避免了悬空
		指针(TODO), 多次释放等手动管理内存时会出现的问题, 具有垃圾回收功能的
		语言屏蔽了内存管理的复杂性, 开发者可以更好的关注核心的业务逻辑;
	- 解耦
		当两个模块同时维护一个内存时, 释放内存必须特别小心, 手动分配的问题在
		于难以在本地模块内做出全局的决定, 而具有垃圾回收功能的语言将垃圾收集
		的工作托管给了具有全局视野的运行时代码, 开发者编写的业务模块将真正实
		现解耦, 从而利于开发和调试;

	因为垃圾回收带来额外的成本, 需要保存内存的状态信息(例如是否使用, 是否包含
	指针)并扫描内存, 很多时候还需要中断整个程序来处理垃圾回收; 因此垃圾回收
	对于要求极致的速度和内存要求极小的场景并不适用, 却是开发大规模, 分布式, 微
	服务集群的极佳选择;

	内存管理和垃圾回收都属于 go 语言最复杂的模块, 没有最完美的垃圾回收算法,
	因为每个应用程序的硬件条件, 工作负载和性能要求都是不同的, 理论上, 可以为
	单独的应用程序设计最佳的内存分配方案;
	通用的具有垃圾回收的编程语言会提供通用的垃圾会收拾算法, 并且每一种语言侧重
	的垃圾回收目标不尽相同; 垃圾回收的常见指标包括程序暂停时间, 空间开销, 回收
	的及时性等, 更具设计目标的侧重点不同有不同的垃圾回收算法;


	以下介绍垃圾回收的5种经典算法:

	标记-清扫(Mark-Sweep)
		主要分两个阶段, 第一阶段扫描并标记当前活着的对象, 第2阶段是清扫没有被标记
		的垃圾对象; 算是一种间接的垃圾回收算法;

		扫描一般从栈上的根对象开始, 只要对象引用了其他对象, 就会一直向下扫描,
		因此可以采取深度优先搜索或广度优先搜索的方式进行扫描;

		在扫描阶段, 为了管理扫描对象的状态, 引入了经典的三色标记算法(TODO);

		标记-清扫算法的缺点在于可能产生内存碎片或空洞, 这会导致新对象分配失败;

	标记-压缩(Mark-Compact)
		通过将分散的, 活着的对象移动到更紧密的空间来解决内存碎片问题; 分为
		标记和压缩阶段:
		- 标记过程与标记-清扫中的标记过程类似;
		- 压缩阶段需要扫描活着的对象并将其压缩到空闲的区域, 这可以保证压缩后的
			空间更紧凑, 从而解决内存碎片问题; 同时, 压缩后的空间能以更快的
			速度查找到空闲的内存区域(在已经使用内存的后方);

		标记-压缩算法的缺点在于内存对象在内存的位置是随机的, 这通常会破坏缓存
		的局部性, 并且时常需要一些额外的空间来标记当前对象已经移动到了其他地方;
		在压缩阶段, 如果B对象发生了转移, 那么必须更新所有引用了B对象的对象的
		指针, 这无疑增加了实现的复杂性;
*/
