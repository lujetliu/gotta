package main

/*
	内存分配器: TODO: 内存分配源码
	程序中的数据和变量都会被分配到程序所在的虚拟内存中, 内存空间包含两个重要
	区域:
	- 栈区(stack)
		函数调用的参数, 返回值以及局部变量大都会被分配到栈上, 这部分内
		存由编译器管理;
	- 堆区(heap)
		堆中的对象由内存分配器分配并由垃圾收集器回收;

	内存管理包含3个组件: 用户程序(mutator), 内存分配器(allocator), 和
	垃圾收集器(collector)
	当用户程序申请内存时, 会通过内存分配器申请内存, 而分配器会负责从堆中初始化
	相应的内存区域
*/

/*
	内存分配方法
	编程语言的内存分配器一般包含两种分配方法:
	- 线性分配器(sequential allocator 或 bump allocator)
	- 空闲链表分配器(free-list allocator)

	线性分配器:
	是一种高效的内存分配方法, 但有较大的局限性; 当使用线性分配器时, 只需要在
	内存中维护一个指向内存特定位置的指针, 如果用户程序向分配器申请内存, 分配器
	只需要检查剩余空闲内存, 返回分配的内存区域并修改指针在内存中的位置;

	 |---------| |-----------------| |---------| |-------------------------|
	 |         | |                 | |         | |                         |
	 |  对象   | |      对象       | |   对象  | |       空闲内存          |
	 |         | |                 | |         | |                         |
	 |---------| |-----------------| |---------| |-------------------------|
		                                          /|\
                                                   |
                                                   |
                                                   |

	虽然线性分配器执行速度快且实现复杂度低, 但是它无法在内存被释放时复用内存;
	 |---------| |-----------------| |---------| |-------------------------|
	 |         | |                 | |         | |                         |
	 |  对象   | |   空闲内存      | |   对象  | |       空闲内存          |
	 |         | |                 | |         | |                         |
	 |---------| |-----------------| |---------| |-------------------------|
		            这里的内存无法复用            /|\
                                                   |
                                                   |

	因为线性分配器的上述特性, 需要与适配的垃圾收集器配合使用, 例如: 标记-压缩,
	复制回收和分代回收等算法, 它们可以通过复制的方式整理存活对象的内存碎片,
	定期合并空闲内存, 从而利用线性分配器的效率提升内存分配的性能;


	空闲链表分配器:
	线性链表分配器可以复用已经被释放的内存, 它在内部会维护一个类似于链表的
	数据结构, 如下图当用户程序申请内存时, 空闲链表分配器会依次遍历空闲内存
	块, 找到足够大的内存, 然后申请资源并修改链表

	 |--------| |--------|-|---------| |--------| |-------| |----------------|
	 |        | |        | |         | |        | |       | |                |
	 |  对象  | |  空闲  | |   对象  | |  空闲  | |  对象 | |     空闲       |
	 |        | |        | |         | |        | |       | |                |
	 |--------| |--------| |---------| |--------| |-------| |----------------|
				  /|\  |                    /|\                 |      /|\
				   |   |---------------------|                  |       |
				   |                                            |       |
		 		   |--------------------------------------------|       |
				                                                        |
				                                                        |

	因为不同的内存块通过指针构成了链表, 所以使用这种方式的分配器可以重新利用
	回收的资源, 但是因为分配内存时需要遍历链表, 所以它的时间复杂度为 O(n); 空
	闲链表分配器可以选择不同的策略在链表的内存块中进行选择, 常见以下4种:
	- 首次适应(first-fit)
		 从链表头开始遍历, 选择第一个大小大于申请内存的内存块;
	- 循环首次适应(next-fit)
		从上次遍历的结束位置开始遍历, 选择第一个大小大于申请内存的内存块;
	- 最优适应(best-fit)
		从链表头遍历整个链表, 选择最合适的内存块;(TODO:大小匹配度最高的为最合适?)
	- 隔离适应(segregated-fit)
		将内存分割成多个链表, 每个链表中的内存块大小相同, 申请内存时先找到
		满足条件的链表, 再从链表中选择合适的内存块;

	go 使用的内存分配策略类似于第4种分配策略, 该策略会将内存分割成4, 8, 16, 32
	字节的内存块组成的链表, 隔离适应的分配策略减少了需要遍历的内存块数量, 提高
	了内存分配效率;

*/

/*
	分级分配 TODO: TCMalloc
	线程缓存分配(thread-caching malloc, TCMalloc) 是用于分配内存的机制, 它比
	glibc 中的 malloc 更快; go 语言的内存分配器借鉴 TCMalloc 的设计实现高速
	内存分配, 其核心理念是使用多级缓存将对象根据大小分类, 并按照类别实施不同
	的分配策略;

	对象大小
	go语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑,
	运行时根据对象的大小将对象分成3种:
	- 微对象    [0, 16B]
	- 小对象    [16B, 32KB]
	- 大对象    [32KB, +∞]
	因为程序中的绝大多数对象小于32KB, 而申请的内存大小影响go语言运行时分配内存
	的过程和开销, 所以分别处理大对象和小对象有利于提高内存分配器的性能;

	多级缓存
	内存分配器不仅会区别对待大小不同的对象, 还会将内存分成不同级别分别管理,
	TCMalloc 和 go 语言运行时分配器都会引入线程缓存(thread cache),
	中心缓存(central cache)和页堆(page heap) 3个组件分级管理内存



		线程		   线程           线程             线程
		 |              |              |                |
		 |              |              |                |
		\|/            \|/            \|/              \|/
	 线程缓存        线程缓存       线程缓存         线程缓存
		 |              |              |                |
		 |              |              |                |
		\|/            \|/            \|/              \|/
	 |--------------------------------------------------------|
	 |                                                        |
	 |                      中心缓存                          |
	 |--------------------------------------------------------|
								|
								|
							   \|/
	 |--------------------------------------------------------|
	 |                                                        |
	 |                        页堆                            |
	 |--------------------------------------------------------|
	                     多级缓存内存分配

	线程缓存属于每一个独立的线程, 它能够满足线程上大多数内存分配需求; 因为
	不涉及多线程, 所以不需要使用互斥锁来保护内存, 这能够减少锁竞争造成的性能
	损耗; 当线程缓存不能满足需求时, 运行时会使用中心缓存作为补充解决小对象
	的内存分配; 在遇到32KB以上的对象时, 内存分配器会选择页堆直接分配大内存;

	这种多层级的内存分配设计与计算机操作系统中的多级缓存类似, 因为多数对象
	是小对象, 所以可以通过线程缓存和中心缓存提供足够的内存空间, 发现资源不
	足时从上一级组件中获取更多内存资源;

*/
