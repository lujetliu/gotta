package main

/*
	调度器
	线程是操作系统调度的最小单元, 而 Linux 调度器并不区分进程和线程的调度, 它
	们在不同的操作系统上的实现也不同, 大多数实现中线程属于进程;

	多个线程可以属于同一个进程并共享内存空间, 因为多线程不需要创建新的虚拟内存
	空间(TODO), 所以不需要内存管理单元处理上下文的切换, 线程之间的通信也正是基
	于共享内存进行的, 与重量级进程相比, 线程显得比较轻量;

	虽然线程比较轻量, 但是调度时也有比较大的额外开销, 每个线程都占用 1MB 以上
	的内存空间, 在切换线程时不止会消耗较多内存, 恢复寄存器中的内容还需要向
	操作系统申请或销毁资源; 每一次线程上下文的切换都需要消耗约1us的时间, 而
	go 调度器对 goroutine 的上下文切换约为 0.2us, 减少了 80% 的额外开销;

	go 语言的调度器使用与 cpu 数量相等的线程来减少线程频繁切换带来的内存开销,
	同时在每个线程上执行额外开销更低的 goroutine 来降低操作系统和硬件的负载;

	在 1.1 版本前的调度器有 G-M 模型组成:

	                                       全局 goroutine 队列
							-------------------------------------------------
			      加锁      |     G1              G2				G3      |
				/    |\	    -------------------------------------------------
               /     |
			  /      |
		放入 /       | 放回
            /       /
		   |       /
		   \      /
		    \|   /
	          M1                 M2             M3

	缺陷:
		- 调度器和锁是全局资源, 所有调度状态都是中心化存储的, 锁竞争问题严重
		- 线程需要经常互相传递可运行的 goroutine, 引入了大量延迟
		- 每个线程都需要处理内存缓存, 导致大量内存占用并影响数据局部性
		- 系统调用频繁阻塞和解除阻塞正在运行的线程, 增加了额外开销

	在 1.1 版本中调度器做了以下优化:
	- 在当前的 G-M 模型中引入了处理器P, 增加中间层
	- 在处理器 P 的基础上实现基于任务窃取的调度器
	任务窃取就是当 P 的本地队列和全局队列都无 goroutine 时从其他 P 中偷取一半
	的 goroutine 到自己的本地队列中

                                            本地队列
		M <--------------- P <---------- G		G		G
						  /|\
						   |
						   |
						   |
						   G
	处理器 P 持有一个由可运行的 goroutine 组成的环形运行队列, 还方向持有一个
	线程, 调度器在调度时会从处理器的队列中选择队列头的 goroutine 放到线程 M
	上执行;
	基于工作窃取的多线程调度器将每一个线程绑定到独立的 CPU 上, 这些线程会由
	不同的处理器管理, 不同的处理器通过工作窃取对任务进行再分配实现任务的平衡,
	也能提升调度器和 go 语言程序的整体性能;

	在 go1.1 中的调度器不支持抢占式调度, 程序只能依靠 goroutine 主动让出 CPU
	资源才能触发调度, go1.2 版本的调度器引入了基于协作的抢占式调度解决了以下
	问题:
		- 某些 goroutine 可以长时间占用线程, 造成其他 goroutine 饥饿;
		- 垃圾收集需要暂停整个程序(STW), 最长可能需要几分钟的时间, 导致程序
			无法工作;

	TODO: 非均匀内存访问调度器

*/
