package main

/*
	GMP 模型
	G 表示 goroutine(用户态线程), 待执行的任务
	M 表示操作系统的线程(内核态线程), 由操作系统的调度器进行调度和管理
	P 表示处理器, 可以看作在线程上运行的本地调度器


	G:
	goroutine 只存在于 go 语言的运行时, 是 go 语言在用户态提供的线程, 是
	粒度更细的资源调度单元;
	TODO: goroutine 的数据结构, 包含哪些状态, 状态迁移原理
	g0 是运行时较特殊的一个 goroutine, 它会深度参与运行时的调度过程, 包括
	goroutine 的创建, 大内存分配和 cgo 函数的执行;

	M:
	m 是操作系统线程, 调度器最多可以创建 10000 个线程, 但是其中大多数线程不会
	执行用户代码(可能会陷入系统调用), 最多只会有 GOMAXPROCS 个活跃线程能够正常
	运行; 默认情况下, 运行时会将 GOMAXPROCS 设置成当前机器的核数;
	多数情况下, go 语言的默认设置也就是线程数等于 CPU 数, 默认设置不会频繁触发
	操作系统的线程调度和上下文切换, 所有调度都发生在用户态, 由 go 语言调度器
	触发, 能减少很多额外开销;

	P:
	调度器中的处理器 P 是线程和 goroutine 的中间层, 它能提供线程需要的上下文,
	也会负责调度线程上的等待队列; 通过处理器 P 的调度, 每一个内核线程都能够
	执行多个 goroutine, 它能在 goroutine 进行一些 I/O 操作时及时让出计算资源,
	提高线程的利用率;
	因为调度器在启动时就会创建 GOMAXPROCS 个处理器, 所以 go 程序的处理器数量
	一定会等于 GOMAXPROCS, 这些处理器会绑定到不同的内核线程上;

*/
