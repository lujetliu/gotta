package main

/*
 * go 编译器不仅能准确的翻译高级语言, 还能进行代码优化.
 *
 * 编译器是个大型且复杂的系统, 一个好的编译器能很好的结合形式语言理论, 算法,
 * 人工智能, 系统设计, 计算机体系结构以及编程语言理论.
 *
 * go 编译器遵循了主流编译器采用的经典策略以及相似的处理流程和优化规则(如经典
 * 的递归下降的语法解析, 抽象语法数的构建), 此外, go编译器还有一些特殊的设计,
 * 例如内存的逃逸等.
 *
 * go 语言的语法特性都离不开编译时与运行时的共同作用.
 *
 */

/*
 * 在经典的编译原理中, 将编译器分为编译器前端, 优化器和编译器后端, 称为3阶段
 * 编译器(three-phase compiler).
 * - 编译器前端: 理解源程序, 扫描解析源程序并进行精准的语义表达
 * - 中间阶段(Intermediate Representation, IR): 可能有多个, 编译器会使用多
 * 个IR阶段, 多种数据结构表示代码, 并在中间阶段对代码进行多次优化(如识别冗余
 * 代码, 识别内存逃逸等).
 * - 编译器后端: 生成特定目标机器上的程序, 可执行文件或需要进一步处理的中间
 * 形态obj文件, 汇编语言等.
 *
 *
 *
 * 编译器优化的主要目的是降低程序对资源的消耗, 常见的是降低内存和cpu的使用率;
 * 同时这种优化不是非常明确的概念, 随着代码的增加, 优化的难度呈指数增长, 因此,
 * 编译器无法进行最佳的优化, 通常采用一种折中的方案.
 *
 * go 编译器缩写为 gc(golang compiler), 与 GC(垃圾回收)进行区分; 编译器的执行
 * 流程可细化为多个阶段, 包括词法解析(./token.go), 语法解析, 抽象语法树构建,
 * 类型检查, 变量捕获(./capture.go), 函数内联(./func), 逃逸分析(./escape.go),
 * 闭包重写(./closure.go), 遍历函数(./walk.go), SSA生成(./ssa.go, ./ssa.html),
 * 机器码生成(./assembler.go, ./ar.go, ./link.go, ./elf.go)
 *
 * 与 go 编译器有关的代码主要位于 $GOROOT/src/cmd/compile/internal 目录中,
 * go 语言的很多语法检查, 语法特性都依赖编译时, 理解编译时的基本流程, 优化方案
 * 及一些调试技巧有助于写出更好的程序.
 *
 */
