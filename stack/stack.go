package main

/*
	栈空间管理
	栈区的内存一般由编译器自动分配和释放, 其中存储着函数的入参和局部变量, 这些
	参数会随着函数的创建而创建, 随着函数的返回而消亡, 一般不会在程序中长期存在;
	这种线性的内存分配策略效率极高;


	寄存器:
		寄存器是CPU中的稀缺资源, 栈区的操作会用到两个以上的寄存器

	栈寄存器(stack register) 是CPU寄存器的一种, 主要作用是跟踪函数的调用栈;
	go 语言的汇编代码包含 BP 和 SP 两个栈寄存器, 它们分别存储了栈的基址指针和
	栈顶的地址, BP 和 SP 之间的内存就是当前函数的调用栈;
	当应用程序申请或者释放栈内存时, 只需要修改 SP 寄存器的值, 这种线性的内存
	分配方式与堆内存相比更加快速, 仅会带来极少的额外开销;


	线程栈:(TODO: 操作系统进程和线程)
		在 Linux 操作系统中执行 pthread_create 系统调用, 进程会启动一个新线程,
		如果用户没有通过软资源限制 RLIMIT_STACK 指定线程栈的大小, 那么操作
		系统会根据架构选择不同的默认栈大小, 多数架构默认栈大小为 2MB-4MB, 但是
		固定栈大小对于应用程序来说不够灵活;
		线程和进程都是代码执行的上下文(TODO: 如何理解), 如果一个应用程序包含
		成百上千个执行上下文并且每个上下文都是线程, 就会占用大量内存空间并带
		来其他额外开销; go 语言在设计时认为执行上下文是轻量级的, 所以在用户
		态实现 goroutine 作为执行上下文;
*/

/*
	在c语言和c++这类需要手动管理内存的编程语言中, 将对象或结构体分配到栈
	上或堆中由工程师自主决定, 但是手动分配内存会导致如下问题:
	- 不需要分配到堆中的对象分配到了堆中, 浪费内存空间;
	- 需要分配到堆中的对象分配到了栈上, 导致产生悬挂指针, 影响内存安全;

	逃逸分析(escape analysis):(TODO: 深入研究)
		在编译器优化中, 逃逸分析是用来决定指针动态作用域的方法, go 语言的编译器
		使用逃逸分析决定哪些变量应该在栈上分配, 哪些变量应该在堆中分配, 其中
		包括使用 new, make 和字面量等方法隐式分配的内存, go 语言的逃逸分析遵循
		以下两个不变性:
		- 指向栈对象的指针不能存在于堆中;
		- 指向栈对象的指针在栈对象回收后无法存活;

	逃逸分析是静态分析的一种, 在编译器解析了 go 语言源文件后, 它可以获得整个
	程序的抽象语法数, 编译器可以根据抽象语法树分析静态的数据流, 主要通过以下
	几个步骤实现静态分析的全过程:
	- 构建带权重的有向图, 其中顶点 cmd/compile/internal/gc.EscLocation 表示
		被分配的变量, 边 cmd/compile/internal/gc.EscEdge 表示变量之间的分配
		关系, 权重表示寻址和取址的次数;(TODO: 源码, 图, 有向图)
	- 遍历对象分配图并查找违反两个不变性的变量分配关系, 如果堆中的变量指向了
		栈上的变量, 那么该变量需要分配到堆中;
	- 记录从函数的调用参数到堆以及返回值的数据流, 增强函数参数的逃逸分析:

	决定变量分配到栈上还是堆中虽然重要, 但这是一个定义相对清晰的问题, 可以
	通过编译器做统一决策; 为了保证内存的绝对安全, 编译器可能会将一些变量
	错误的分配到堆中, 但是因为堆也会被垃圾收集器扫描, 所以不会造成内存泄露
	以及悬挂指针等安全问题, 解放了工程师的生产力;


	栈内存空间:
		go 语言使用用户态线程 goroutine 作为执行上下文, 它的额外开销和默认
		栈大小都比线程小很多, 为 2KB;

		分段栈:
			go1.3 之前的实现, 分段栈的内存空间不连续, 但是当前 goroutine
			的多个栈空间会以链表的形式串联起来, 运行时会通过指针找到连续的栈片段;

			分段栈虽然能按需为当前 goroutine 分配内存并且及时减少内存占用,
			但是它也存在两个比较大的问题:(TODO: 深入理解)
			- 如果当前 goroutine 的栈几乎充满, 则任意函数调用都会触发栈扩容,
				当函数返回后又会触发栈缩容; 如果在一个循环中调用函数, 栈的
				分配和释放就会产生巨大的额外开销, 这称为热分裂(hot split)问题(TODO)
			- 一旦 goroutine 使用的内存越过了分段栈的扩缩容阈值, 运行时会触发
				栈的扩容或缩容, 带来额外的工作量;

		连续栈:
			连续栈可以解决分段栈中存在的两个问题, 其核心原理是每当程序的栈空间
			不足时, 初始化一块更大的栈空间并将原堆中所有的值都迁移到新堆中,
			新的局部变量或者函数调用就有了充足的内存空间, 使用连续栈机制时,
			栈空间不足导致的扩容会经历以下步骤:
			- 在内存空间中分配更大的栈内存空间;
			- 将旧堆中的所有内容复制到新堆中;
			- 将指向旧栈对应变量的指针重新指向新栈; (TODO)
			- 销毁并回收旧栈的内存空间;

			对于第三部调整指针, 因为复制变量和调整指针, 所以连续栈增加了栈扩容
			时的额外开销, 但是通过合理的栈缩容机制就能避免热分裂带来的性能问题,
			在 GC 期间如果 goroutine 使用了栈内存的 1/4, 就将内存减半, 这样在
			栈内存几乎充满时也只会扩容一次, 不会因为函数调用频繁扩缩容;
			(TODO: 参考切片的扩容理解)
*/

/*
	栈操作
	TODO:
		- 栈初始化
		- 栈上分配
		- 栈扩容
		- 栈缩容

	栈内存是 go 语言应用程序中重要的内存空间, 它支持本地的局部变量和函数调用,
	栈空间中的变量会与栈一同创建和销毁, 这部分内存空间不需要工程师过多干预和
	管理;
*/
