package main

/*
	Go的垃圾回收, 让堆和栈堆程序员保持透明; 真正解放了程序员的双手, 让他们可以
	专注于业务, 高效地完成代码编写, 把那些内存管理的复杂机制交给编译器;
	知乎: https://zhuanlan.zhihu.com/p/113643434

	栈:
	函数调用内部申请到的内存, 它们会随着函数的返回把内存还给系统;

	堆:
	申请后作为返回值返回了, 编译器会认为在退出函数之后还有其他地方在引用;
	当函数返回之后并不会将其内存归还, 那么就申请到堆里;
	如果变量都分配到堆上, 堆不像栈可以自动清理; 会引起Go频繁地进行垃圾回收,
	而垃圾回收会占用比较大的系统开销;


	堆和栈相比
	堆适合不可预知的大小的内存分配, 但是为此付出的代价是分配速度较慢,
	而且会形成内存碎片;

	栈内存分配则会非常快, 栈分配内存只需要两个指令: PUSH 和 POP 分配和释放;
	而堆分配内存首先需要去找到一块大小合适的内存块, 之后要通过垃圾回收才能释放;

	逃逸分析
	逃逸分析是一种确定指针动态范围的方法, 简单来说就是分析在程序的哪些地方
	可以访问到该指针;

	简单来说，编译器会根据变量是否被外部引用来决定是否逃逸:
	- 如果函数外部没有引用, 则优先放到栈中;
	- 如果函数外部存在引用, 则必定放到堆中;
	可以认为逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为;


	如何得知变量是分配在栈（stack）上还是堆（heap）上:
	Golang 中的变量只要被引用就一直会存活, 存储在堆上还是栈上由内部实现决定
	而和具体的语法没有关系;
	知道变量的存储位置确实和效率编程有关系, 如果可能, Golang 编译器会将函数
	的局部变量分配到函数栈帧(stack frame)上; 然而, 如果编译器不能确保变量在
	函数 return之后不再被引用, 编译器就会将变量分配到堆上; 而且, 如果一个局
	部变量非常大, 那么它也应该被分配到堆上而不是栈上;

	如果一个变量被取地址, 那么它就有可能被分配到堆上; 然而, 还要对这些变量
	做逃逸分析, 如果函数return之后, 变量不再被引用, 则将其分配到栈上;


	函数传递指针真的比传值效率高吗？TODO: 深入理解
	传递指针可以减少底层值的拷贝, 可以提高效率, 但是如果拷贝的数据量小,
	由于指针传递会产生逃逸, 可能会使用堆, 也可能会增加GC的负担, 所以传递
	指针不一定是高效的;
*/

type Student struct {
	Name string
	Age  int
}

// 虽然在函数 StudentRegister() 内部 s 为局部变量, 其值通过函数返回值返回,
// s 本身为一指针, 其指向的内存地址不会是栈而是堆, 这就是典型的逃逸案例
func StudentRegister(name string, age int) *Student {
	s := new(Student) //局部变量s逃逸到堆

	s.Name = name
	s.Age = age

	return s
}

func main() {
	StudentRegister("Jim", 18)
}

// 指令集 -gcflags 用于将标识参数传递给 Go 编译器
// go build -gcflags=-m escape.go
// ./main.go:8:6: can inline StudentRegister
// ./main.go:17:6: can inline main
// ./main.go:18:17: inlining call to StudentRegister
// ./main.go:8:22: leaking param: name
// ./main.go:9:10: new(Student) escapes to heap
// ./main.go:18:17: new(Student) does not escape  ?
// 内联的函数内部对于main来说没有逃逸?
