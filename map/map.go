package main

/*
	哈希表:
	哈希表是除数组外最常见的数据结构, 数组用于表示元素的序列, 而哈希表表示的是
	键值对之间的映射关系;
	哈希表是计算机科学中最重要的数据结构之一, 不仅是因为它的读写性能优秀(O(1)),
	还因为它提供了键值之间的映射, 要实现一个性能优异的哈希表, 需要注意两个关键
	点: 哈希函数和冲突解决方法


	哈希函数:
	实现哈希表的关键点在于哈希函数的选择, 在很大程度上决定哈希表的读写性能; 理想
	状态下, 哈希函数应该能将不同键映射到不同索引上, 这要求哈希函数的输出范围大于
	输入范围, 但是实际上键的数量会远远大于映射的范围; 所以要尽可能的让哈希函数
	的结果均匀分布, 然后通过工程手段解决哈希冲突的问题, 哈希函数映射的结果要尽
	肯均匀, 结果不均匀的哈希函数会导致哈希冲突增加, 读写性能下降;

	如果使用结果分布较为均匀的哈希函数, 那么哈希表的增删改查的时间复杂度为O(1);
	如果哈希函数的结果分布不均匀, 那么所有操作的时间复杂度可能会达到(O(n));


	解决冲突:
	(哈希冲突: 不是多个键对应的哈希完全相等, 可能是多个哈希的部分相等, 例如两
	个键对应哈希的前4个字节相同)
	在使用哈希表时一定会遇到冲突, 即使使用了完美的哈希函数, 当输入的键足够多
	时也会产生冲突, 所以需要解决哈希冲突问题, 常用方法有开放寻址法和拉链法


	开放寻址法:(仅做了解)
	是一种在哈希表中解决哈希冲突的方法, 这种方法的核心思想是: 依次探测和比较数组
	中的元素以判断目标键值对是否存在于哈希表中; 开放寻址法中对性能影响最大的是
	装载因子, 它是数组中元素数量与数组大小的比值, 随着装载因子的增加, 线性探测
	的平均用时会逐渐增加, 这会影响哈希表的读写性能;

	拉链法:(TODO: go 代码实现, map 源码, 链表)
	拉链法是哈希表最常见的实现方法, 大多数编程语言都使用拉链法实现哈希表, 相对
	开放寻址法, 它的平均查找的长度较短, 各个用于存储节点的内存都是动态申请的,
	所以可以节省比较多的存储空间;
	实现拉链法一般会使用数组加上链表, 有的编程语言会在拉链法的哈希表中引入红黑
	树以优化性能; 拉链法会使用链表数组作为哈希底层的数据结构, 可以将其看为可以
	扩展的二维数组;
	链表称为桶, 需要将一个键值对(key6, value6)写入哈希表时, 键值对中的键key6
	会先经过一个哈希函数, 根据哈希函数返回的哈希选择桶, 直接对哈希函数返回的
	结果取模: index := hash("key6") % array.len




							key6                   key7
							value6                 value7
                              |                      |
						     \|/                    \|/
						____________________________________
                        |    |                      |      |
						|    |       哈希函数       |      |
						|____|______________________|_____ |
							 |                      |
						    \|/                    \|/
    桶:     0		1		2		3		4		5		6
			key2    key1    key4                    key3
			value2  value1  value4                  value3
							key6                    key5
							value6                  value5
													key7
													value7

	选择2号桶后就可以遍历当前桶中的链表了, 在遍历链表的过程中:
	- 若找到键相同的键值对, 则更新键对应的值;
	- 若没找到键相同的键值对, 则在链表末尾追加新的键值对;

	在性能比较好的哈希表中, 每个桶中都应该有0-1个元素, 有时会有2-3个, 很少会超
	过这个数量, 计算哈希, 定位桶和遍历链表3个过程是哈希表读写操作的主要开销;
	拉链法的装载因子:
		装载因子 = 元素数量 ÷ 桶数量
	可以得出拉链法的装载因子越大, 哈希表的读写性能就越差; 一般情况下拉链法的
	哈希表装载因子不会超过1; 当哈希表的装载因子较大时会触发哈希表扩容(TODO),
	创建更多的桶来存储哈希表中的元素, 避免性能严重下降(TODO: 实践)


	go 中的 map:
	使用字面量初始化map:
	hash := map[string]int{
		"1": 2,
		"3": 4,
		"5": 6,
	}
	当哈希表中的元素少于或等于25时, 编译器会将字面量初始化的结构体转换成以下
	代码:
		hash := make(map[string]int, 3)
		hash["1"] = 2
		hash["3"] = 4
		hash["5"] = 6
	这种初始化方法与初始化数组和切片几乎完全相同, 由此看来集合类型的初始化在go
	中有着相同的处理逻辑;
	一旦哈希表中的元素超过25个, 编译器就会创建两个数组分别存储键和值, 这些键
	值对会通过如下 for 循环加入哈希表:
	hash := make(map[string]int, 26)
	vstak := []string{"1", "2", "3", ..., "26"}
	vstav := []string{1, 2, 3, ..., 26}
	for i:=0; i<len(vstak); i++ {
		hash[vstak[i]] = vstav[i]
	}
	使用字面量初始化的过程都会使用 go 的关键字 make 创建新的哈希表, 并通过最
	原始的[]语法向哈希表追加元素;


	当使用 v, ok := hash[k] 的形式访问哈希表中的元素时, 能够通过这个布尔值更
	准确的知道; 当 v == nil 时, v 到底是哈希表中存储的元素还是表示该键对应的
	元素不存在; 所以在访问哈希表时, 更推荐使用这个方式判断元素是否存在;

	与切片一样, 哈希表可能会在装载因子过高或者溢出桶时过多时进行扩容, 哈希表
	扩容并不是原子过程, 需要在扩容过程中保证哈希表的访问(TODO: 扩容)

*/
