package main

/*
	网络通信是服务端程序必不可少的一部分, 而基于 TCP Socket(套接字) 的通信
	则是网络的主流; TODO: 《UNIX网络编程 卷1: 套接字联网API》, 该书详细
	讲解了TCP Socket 接口的各种使用方法, 行为模式, 异常处理等

	go 是自带运行时的跨平台编程语言, go 中暴露给语言使用者的 TCP Socket
	接口是建立在操作系统原生TCP socket 接口之上的; 由于go运行时调度的
	需要, go 设计了一套适合自己的 TCP Socket 网络编程模型;

	网络I/O模型定义的是应用线程与操作系统内核之间的交互行为模式, 常以
	阻塞(Blocking)和非阻塞(Non-Blocking)描述网络I/O模型; 不同标准对于
	网络I/O模型的定义有所区别, POSIX.1标准还定义了同步(Sync)和异步(Async)
	术语;

	阻塞和非阻塞是以内核是否等数据全部就绪才返回(给发起系统调用的应用线程)
	来区分的;
	- 阻塞:	内核一直等到全部数据就绪才返回
	- 非阻塞: 内核查看数据就绪状态后, 即便没有就绪也立即返回错
		误(给发起系统调用的应用线程)


	常见的网络I/O模型:
	1. 阻塞I/O模型
		阻塞I/O模型是最常用的模型; 在阻塞I/O模型下, 在用户空间应用线程向操作
		系统内核发起I/O请求后(一般为操作系统提供的I/O系统调用), 内核将尝试执
		行该I/O操作, 并等所有数据就绪后, 将数据从内核空间复制到用户空间,
		最后系统调用从内核空间返回; 而在这期间, 用户空间应用线程将阻塞在
		该I/O系统调用上, 无法进行后续处理, 只能等待; 因此, 在这样的模型下,
		所有Socket默认都是阻塞的; 一个线程仅能处理一个网络连接上的数据通信,
		即便连接上没有数据, 线程也只能阻塞在对Socket的读操作上, 等待对端
		的数据;

	2. 非阻塞I/O模型
		在非阻塞模型下, 在用户空间线程向操作系统内核发起I/O请求后, 内核会
		执行该I/O操作; 如果此刻数据尚未就绪, 则会立即将“未就绪”的状态以
		错误码形式(如EAGAIN/EWOULDBLOCK, TODO)返回给此次I/O系统调用的发起者;
		而后者则根据系统调用的返回状态决定下一步如何做, 在非阻塞模型下,
		位于用户空间的I/O请求发起者通常会通过轮询的方式一次次发起I/O请求,
		直到读到所需的数据; 同时这样的轮询是对CPU计算资源的极大浪费,
		因此非阻塞I/O模型单独应用的比例并不高, 阻塞的Socket默认可以
		通过fcntl(TODO)调用转变为非阻塞Socket;

	3.  I/O多路复用模型
		I/O多路复用模型建立在操作系统提供的select/poll等多路复用函数
		(以及性能更好的epoll等函数)的基础上;
		在该模型下, 应用线程首先将需要进行I/O操作的Socket都添加到多路
		复用函数中(以select为例), 接着阻塞, 等待select系统调用返回;
		当内核发现有数据到达时, 对应的Socket具备通信条件, select函数返回;
		然后用户线程针对该Socket再次发起网络I/O请求(如read); 由于数据
		已就绪, 因此即便Socket是阻塞的, 第二次网络I/O操作也非常快;
		阻塞模型一个线程仅能处理一个Socket, 而在I/O多路复用模型中, 应用
		线程可以同时处理多个Socket; 虽然可同时处理多个Socket, 但I/O多路
		复用模型由内核实现可读/可写事件的通知, 避免了非阻塞模型中轮询
		带来的CPU计算资源的浪费;

		多路复用函数会阻塞的监听一组文件描述符, 当文件描述符的状态变为
		可读或可写时, select 会返回可读事件或可写事件的个数, 应用程序
		可以在输入的文件描述符中查找哪些可读或可写, 然后执行相应操作;



	4. 异步I/O模型
		用户应用线程发起异步I/O调用后, 内核将启动等待数据的操作并马上返回;
		之后, 用户应用线程可以继续执行其他操作, 既无须阻塞, 也无须轮询并再
		次发起I/O调用; 在内核空间数据就绪并被从内核空间复制到用户空间后,
		内核会主动生成信号以驱动执行用户线程在异步I/O调用时注册的信号处理
		函数, 或主动执行用户线程注册的回调函数, 让用户线程完成对数据的处理;

		异步I/O模型受各个平台的支持程度不一, 且使用起来复杂度较高, 在如何
		进行内存管理、信号处理/回调函数等逻辑设计上会给开发人员带来不小的
		心智负担;

	有些标准使用同步和异步来描述网络I/O操作模型; 同步I/O指的是能引起请求线
	程阻塞, 直到I/O操作完成, 而异步I/O则不引起请求线程的阻塞;
	目前主流网络服务器采用的多是I/O多路复用模型, 有的也结合了多线程;


	go 语言结合自身特点将I/O多路复用模型的复杂性隐藏在go运行时中, 在大多数
	情况下, go 开发者无须关心 Socket 是否是阻塞的, 也无须将 Socket 文件
	描述符的回调函数注册到类似select这样的系统调用中, 而只需在每个连接对应
	的 goroutine 中以最简单, 最易用的阻塞I/O模型的方式进行 Socket 操作即可;


	TODO: netpoller, select
	在例子 ./tcp/server.go 中介绍了 netpoller
	Go语言在netpoller中采用了I/O多路复用模型, 因为最常见的多路复用系统
	调用select有比较多的限制, 比如监听Socket的数量有上限(1024)、时间复
	杂度高等, Go运行时选择了在不同操作系统上使用操作系统各自实现的高性能
	多路复用函数, 比如Linux上的epoll、Windows上的iocp、FreeBSD/macOS上的
	kqueue、Solaris上的event port等, 这样可以最大限度地提高netpoller的调
	度和执行性能;
	操作系统中还提供了比较相似的 poll 函数, 其使用链表存储文件描述符,
	摆脱了1024的数量上限; TODO

	Socket 属性
	原生Socket API提供了丰富的sockopt设置接口, 而Go有自己的网络编程模型;
	Go提供的socket options接口也是基于上述模型的必要的属性设置,
	包括SetKeepAlive、SetKeep-AlivePeriod、SetLinger、SetNoDelay (默认为no
	delay)、SetWriteBuffer、SetReadBuffer等(TODO)

	tcpConn, ok := c.(*TCPCon)
	if !ok {
		// 错误处理
	}

	tcpConn.SetNoDealy(true)
	对于 listener 的监听 Socket, go 默认设置了SO_REUSEADDR, 这样重启服务,
	不会因 address in use 的错误而重启失败;
*/
