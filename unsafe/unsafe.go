package main

/*
	unsafe 非常简洁, 定义了一个类型和三个函数, 其中 ArbitraryType 并不真正属于
	unsafe 包, 其表示一个任意表达式的类型, 仅用于文档目的, go 编译器会对其做
	特殊处理(TODO)
	- ./unsafe_sizeof.go
	- ./unsafe_alignof.go
	- ./unsafe_offsetof.go

	unsafe 包中定义了 unsafe.Pointer 类型, unsafe.Pointer 类型可用于表示任意
	类型的指针, 并且具备以下其他指针类型不具备的性质:
	- 任意类型的指针都可以被转换为 unsafe.Pointer
	- unsafe.Pointer 也可以被转换为任意类型的指针值
	- uintptr 类型值可以被转换为一个 unsafe.Pointer
	- unsafe.Pointer 也可以被转换为一个 uintptr 类型值
*/

// 可以通过 unsafe.Pointer 很容易的穿透go的类型安全保护, 对比以下代码:
// ./c_not_type_safe.c
// ./go_type_safe.go
//

/*
	go 提供 unsafe 包以满足运行时或性能敏感系统对性能的需求, unsafe 包所具有的
	独一无二的穿透类型安全保护的能力使得其被广泛应用于 go 标准库和go运行时
	实现当中, reflect, sync, syscall 和 runtime 包都是 unsafe 包的重度用户,
	这些包有的需要绕过 go 类型保护直接操作内存, 有的对性能敏感, 还有的与操作
	系统或c语言低级代码交互频繁;
*/

/*
	reflect 包中 unsafe 包的典型应用
	ValueOf 和 TypeOf 函数是 reflect 包中使用最多的两个API, 它们是进入运行
	时反射层, 获取反射层信息的入口; 这两个函数将任意类型变量转换为一个
	interface{} 类型变量, 再利用 unsafe.Pointer 将这个变量绑定的内存区域
	重新解释为 reflect.emptyinterface 类型, 以获得传入变量的类型和值的
	信息; TODO

	// ValueOf returns a new Value initialized to the concrete value
	// stored in the interface i. ValueOf(nil) returns the zero Value.
	func ValueOf(i any) Value {
		if i == nil {
			return Value{}
		}

		// TODO: Maybe allow contents of a Value to live on the stack.
		// For now we make the contents always escape to the heap. It
		// makes life easier in a few places (see chanrecv/mapassign
		// comment below).
		escapes(i)

		return unpackEface(i)
	}

	// unpackEface converts the empty interface i to a Value.
	func unpackEface(i any) Value {
		e := (*emptyInterface)(unsafe.Pointer(&i))
		// NOTE: don't read e.word until we know whether it is really a pointer or not.
		t := e.typ
		if t == nil {
			return Value{}
		}
		f := flag(t.Kind())
		if ifaceIndir(t) {
			f |= flagIndir
		}
		return Value{t, e.word, f}
	}

	// emptyInterface is the header for an interface{} value.
	type emptyInterface struct {
		ptyp  *rtype
		word unsafe.Pointer
	}

*/

/*
	sync 包中 unsafe 包的典型应用
	sync.Pool 是一个并发安全的高性能临时对象缓冲池, sync.Pool 为每个P分配了
	一个本地缓冲池, 并通过下面的函数实现快速定位P的本地缓冲池: TODO: 源码

	func indexLocal(l unsafe.Pointer, i int) *poolLocal {
		lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{}))
		return (*poolLocal)(lp)
	}

	indexLocal 函数的本地缓冲池快速定位是通过结合 unsafe.Pointer 与 uintptr 的
	指针运算实现的;

*/

/*
	syscall 包中 unsafe 包的典型应用
	标准库中的 syscall 包封装了与操作系统交互的系统调用接口, 比如 Stat, Listen
	和 Select 等:


	// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

	func Listen(s int, n int) (err error) {
		_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)
		if e1 != 0 {
			err = errnoErr(e1)
		}
		return
	}


	// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT

	func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) {
		r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)
		n = int(r0)
		if e1 != 0 {
			err = errnoErr(e1)
		}
		return
	}

	可以看到这类封装的高级调用最终都会调用下面一系列 Syscall 和 RawSyscall 函数
	上:
	func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
	func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)
	func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
	func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)
	这些 Syscall 系列函数接受的参数类型均为 uintptr, 这样当封装的系统调用的
	参数为指针类型时, 只能通过 unsafe.Pointer 将指针指向的地址值转为 uintptr 值,
	因此, syscall 包是 unsafe 包的重度"用户", 它的实现离不开 unsafe.Pointer;

*/

/*
	runtime包中的unsafe包的典型应用
	runtime 包实现的 goroutine 调度和内存管理(包括gc)都使用了 unsafe 包(TODO)
*/

/*
	在很多开源项目中都使用了 unsafe 包, unsafe.Pointer 是其中使用最多的特性,
	而其他三个函数则使用较少, unsafe 包在开源项目中主要被用于如下两个场景:
	- 与操作系统以及非go编写的代码的通信
		与操作系统的通信主要通过系统调用进行, 而与非go编写的代码的通信则主
		要是通过cgo方式

	- 高效类型转换
		使用 unsafe 包可以绕过go类型系统的安全检查, 因此可以通过 unsafe 包实现
		性能更好的类型转换, 最常见的是 string 与 []byte 类型间的相互转换
		./unsafe_string_byte.go

	此外, unsafe 包在自定义高性能序列化函数(marshal), 原子操作(atomic)及内
	存操作(指针运算)上都有一定程度的运用;
	TOOD: <破坏的类型安全: 对unsafe包使用的研究>, https://arxiv.org/abs/2006.09973

*/
