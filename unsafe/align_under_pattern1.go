package main

import (
	"fmt"
	"unsafe"
)

/*
	模式1: *T1 -> unsafe.Pointer >- *T2 的内存对齐
	内存重解释实现的类型转换后类型T2的对齐系数不能比转换前类型T1的对齐
	系数更严格, 即Alignof(T1) >= Alignof(T2);
*/

func main() {
	var a = [10]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}
	var p = (*uint64)(unsafe.Pointer(&a[5]))

	fmt.Printf("a[5]的地址: %p\n", &a[5])
	fmt.Printf("a[5]的对齐系数: %d\n", unsafe.Alignof(a[5]))

	fmt.Printf("p的地址: %p\n", p)
	fmt.Printf("p的对齐系数: %d\n", unsafe.Alignof(p))

	fmt.Printf("*p = %d\n", *p)
}

// a[5]的地址: 0xc0000140f5
// a[5]的对齐系数: 1
// p的地址: 0xc0000140f5
// p的对齐系数: 8
// *p = 151521030
//
//								151521030 (uint64)
//                                 |
//                                 |
//                                 |
//                                \|/
//
// |----32位-----|---------------32位------------------|
// |     0       |    9    |   8    |   7    |   6     |
// |  0000~      | 00001001 00001000 00000111 00000110 |
// 在 0xc0000140f5 地址开始的相继4个地址分别存储了 6, 7, 8, 9 四个 byte 值,
// 第5个地址中存储了 0;  p 类型为 uint64(8字节), 所以不满足 byte 类型的对齐,
// 需要把从 0xc0000140f5 开始后的8个字节存储的值看做 p 解引用后的值,
// (TODO: 后面3个字节因为超出了[10]byte, 所以认为存储的是0吗?), 所以使用大端
// (TODO: 小端?)序展示出来的 *p 为 151521030; TODO: 深入验证和理解

/*
	将[10]byte数组中a[5]的地址重解释成了一个uint64类型数据, a[5]是一个byte
	类型元素, 其对齐系数为1, 因此其地址0x0xc0000160c5是满足其对齐要求的;
	但是一个uint64类型数据的对齐系数为8, 如果给这个类型变量分配的内存起
	始地址为0x0xc0000160c5, 该地址无法被其对齐系数8整除, 这说明这个地址
	没法满足uint64类型的对齐要求; 在x86平台(属于复杂指令集)上, 对这种未
	对齐的地址进行指针解引用并不会造成严重后果(可能会对性能有少许影响), 但是
	在一些对内存地址对齐比较严格的平台(如SPARC、ARM等)上, 对未对齐内存
	地址进行指针解引用可能会出现"总线错误"等无法恢复的异常情况并导致程序崩溃;

	所以转换后类型T2的对齐系数不能比转换前类型T1的对齐系数更严格,
	即Alignof(T1) >= Alignof(T2);
*/

/*
	Go 1.14编译器在-race和-msan命令行选型开启的情况下，会执行-d=checkptr检查,
	确保当将*T1类型按模式1通过unsafe.Pointer转换为*T2时, T2的内存地址对齐系数
	不能高于T1的对齐系数;
*/
// go run -race align_under_pattern1.go
// fatal error: checkptr: converted pointer straddles multiple allocations
