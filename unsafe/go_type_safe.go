package main

/*
	在 go 语言中无法通过常规语法手段穿透 go 在类型系统层面对内存数据的保护;
	与 c  语言相比(./c_not_type_safe.c), go 在常规操作下是类型安全的;
	所谓类型安全指一块内存数据一旦被特定的类型所解释(该内存数据与该类型变量
	建立关联, 也即变量定义), 它就不能再被解释为其他类型, 不能再与其他类型
	变量建立关联;
	go 语言的类型安全是建立在go编译器的静态检查以及go运行时利用类型信息进行的
	运行时检查之上的, 在语法层面为了实现常规操作下的类型安全, go对语法做了很
	多限制:
		- 不支持隐式类型转换, 所有类型转换必须显示进行, 只有底层类型(underlying
			type)相同的两个类型的指针之间才能进行类型转换;
		- 不支持指针运算

	但是在考虑类型安全的同时还要兼顾性能以及实现与操作系统, C代码等互操作的
	低级代码等问题, 所以go在标准库中内置了 unsafe 包, 使用  unsafe 包可以实现
	性能更高, 与底层系统交互更容易的低级代码, 但 unsafe 包的存在也使程序员有了
	绕过go类型安全屏障的方法; 一旦使用不当, 便可能会引入安全漏洞, 引发程序崩溃
	等问题, 难以发现和调试;
*/

import "fmt"

func main() {
	a := 0x12345678
	fmt.Printf("0x%x\n", a) // 0x12345678

	var p *byte = (*byte)(&a) // 错误: 不允许将 &a 从 *int 类型显示转换为 *byte
	*p = 0x23

	var b byte = byte(a)    // b 是一个新变量, 有自己所解释的内存空间
	b = 0x23                // 即使强制进行类型转换, 原变量a所解释的内存空间的数据依然不变
	fmt.Printf("0x%x\n", b) // 0x23
	fmt.Printf("0x%x\n", a) // 0x12345678
}
